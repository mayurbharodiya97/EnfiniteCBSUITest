import jsPDF from "jspdf";
import "jspdf-autotable";
import ProjectLogo from "assets/images/easy_bankcore_Logo.png";
import { format } from "date-fns/esm";

const exportToPDF = (
  data,
  companyName,
  generatedBy,
  RequestingBranchCode,
  barnchDtl
) => {
  const doc: any = new jsPDF({
    orientation: "portrait",
    unit: "mm",
    format: "a4",
  });

  doc.setFontSize(6);
  doc.text(
    `Generated On : ${format(
      new Date(),
      "dd/MM/yyyy"
    )} / Generated By : ${generatedBy} / Requesting Branch Code : ${RequestingBranchCode}`,
    10,
    5
  );

  const margin = 10; // Margin size in pixels
  const spacing = 15; // Spacing between sections in pixels
  let startY = margin;
  let exportContentStartY = 0;

  const pageWidth = doc.internal.pageSize.getWidth() - margin * 2;

  // Add the bank logo
  const logoWidth = 30;
  const logoHeight = 12;
  const logoX = spacing;
  const logoY = margin;
  doc.addImage(ProjectLogo, "PNG", logoX, logoY, logoWidth, logoHeight);

  // Add the bank name and address
  doc.setFont("helvetica", "bold");
  doc.setFontSize(12);
  const bankNameX = logoX + logoWidth + 30;
  const bankNameY = logoY + 7;
  const bankName = doc.splitTextToSize(barnchDtl?.branchName, pageWidth);
  doc.text(bankName, bankNameX, bankNameY);
  doc.setFont("helvetica", "normal");
  doc.setFontSize(6);
  const bankAddressX = bankNameX;
  const bankAddressY = bankNameY + 6;
  doc.text(barnchDtl?.branchAddress, bankAddressX, bankAddressY, {
    maxWidth: 100,
  });
  doc.setFont("helvetica", "normal");
  doc.setFontSize(6);
  const bankPhoneNumberX = bankAddressX;
  const bankPhoneNumberY = bankAddressY + 6;
  doc.text(barnchDtl?.branchPhoneNumber, bankPhoneNumberX, bankPhoneNumberY, {
    maxWidth: 100,
  });
  doc.setFont("helvetica", "normal");
  doc.setFontSize(6);
  const ifscCodeX = bankPhoneNumberX;
  const ifscCodeY = bankPhoneNumberY + 4;
  doc.text(`IFSC CODE : ${barnchDtl?.ifscCode}`, ifscCodeX, ifscCodeY, {
    maxWidth: 100,
  });

  // Draw a horizontal line
  const lineY = ifscCodeY + 8;
  const lineWidth = pageWidth;
  const lineX = margin;
  doc.setLineWidth(0.5);
  doc.line(lineX, lineY, lineX + lineWidth, lineY);

  startY += 35;

  for (const section of data) {
    if (section.DISPLAY_TYPE === "simple") {
      // Check if section has details
      if (section.DETAILS && section.DETAILS.length > 0) {
        doc.setFont("Roboto", "normal");
        doc.setFontSize(8);

        const tableData: any = [];
        let leftData: any = [];
        let rightData: any = [];

        // Divide the data into left and right arrays
        for (let i = 0; i < section.DETAILS.length; i++) {
          if (i < section.DETAILS.length / 2) {
            leftData.push(section.DETAILS[i]);
          } else {
            rightData.push(section.DETAILS[i]);
          }
        }

        // Add empty values if left or right data is shorter
        const maxLength = Math.max(leftData.length, rightData.length);
        for (let i = leftData.length; i < maxLength; i++) {
          leftData.push({ LABEL: "", VALUE: "" });
        }
        for (let i = rightData.length; i < maxLength; i++) {
          rightData.push({ LABEL: "", VALUE: "" });
        }

        // Combine left and right data into tableData array
        for (let i = 0; i < maxLength; i++) {
          tableData.push([
            leftData[i].LABEL,
            leftData[i].VALUE,
            rightData[i].LABEL,
            rightData[i].VALUE,
          ]);
        }

        // Create table with four columns
        doc.autoTable({
          startY,
          head: [[{ content: section?.TITLE, colSpan: 4 }]],
          body: tableData,
          theme: "grid",
          headStyles: {
            fillColor: [66, 99, 199],
            textColor: [255, 255, 255],
            fontSize: 8,
            halign: "center",
          },
          styles: { fontSize: 8 },
          columnStyles: {
            0: { cellWidth: 35, fontStyle: "bold" },
            1: { cellWidth: 55 },
            2: { cellWidth: 35, fontStyle: "bold" },
            3: { cellWidth: 55 },
          },
        });

        // Update the startY position based on the table height
        const tableHeight = doc.previousAutoTable.finalY - startY;
        startY += tableHeight + spacing;

        // Add horizontal line
        doc.setLineWidth(0.1); // Set the line width (adjust as needed)
        doc.line(
          lineX,
          startY - spacing / 2,
          lineX + lineWidth,
          startY - spacing / 2
        );
      }
    } else if (section.DISPLAY_TYPE === "grid") {
      startY += 5;

      // Add section title
      doc.setFont("Roboto", "bold");
      doc.setFontSize(14);

      const titleWidth =
        (doc.getStringUnitWidth(section?.TITLE) * doc.internal.getFontSize()) /
        doc.internal.scaleFactor;
      const titleX = (pageWidth - titleWidth) / 2;

      doc.text(titleX, startY, section?.TITLE);
      startY += 5;
      const tableHeaders = section?.METADATA.map((item) => item?.LABEL);

      const tableData = section?.DATA?.map((item) => {
        const rowData: any = [];
        if (section?.DATA?.length === 0) {
          return rowData.push["Data not found"];
        } else {
          section?.METADATA.forEach((column) => {
            const accessor = column.ACCESSOR;
            rowData.push(item[accessor]);
          });
          return rowData;
        }
      });

      doc.autoTable({
        head: [tableHeaders],
        body: tableData,
        startY: startY, // Adjust startY to add spacing between sections
        headStyles: {
          fillColor: [66, 99, 199],
          textColor: [255, 255, 255],
          fontSize: 8,
        },
        styles: { fontSize: 8 },
        didDrawPage: (data) => {
          startY = data.cursor.y + spacing;
        },
      });

      // Add horizontal line
      doc.setLineWidth(0.1); // Set the line width (adjust as needed)
      doc.line(
        lineX,
        startY - spacing / 2,
        lineX + lineWidth,
        startY - spacing / 2
      );
    } else if (section.DISPLAY_TYPE === "simpleGrid") {
      // Check if section has details
      if (section.DETAILS && section.DETAILS.length > 0) {
        doc.setFont("Roboto", "normal");
        doc.setFontSize(8);

        const tableData: any = [];
        let leftData: any = [];
        let rightData: any = [];

        // Divide the data into left and right arrays
        for (let i = 0; i < section.DETAILS.length; i++) {
          if (i < section.DETAILS.length / 2) {
            leftData.push(section.DETAILS[i]);
          } else {
            rightData.push(section.DETAILS[i]);
          }
        }

        // Add empty values if left or right data is shorter
        const maxLength = Math.max(leftData.length, rightData.length);
        for (let i = leftData.length; i < maxLength; i++) {
          leftData.push({ LABEL: "", VALUE: "" });
        }
        for (let i = rightData.length; i < maxLength; i++) {
          rightData.push({ LABEL: "", VALUE: "" });
        }

        // Combine left and right data into tableData array
        for (let i = 0; i < maxLength; i++) {
          tableData.push([
            leftData[i].LABEL,
            leftData[i].VALUE,
            rightData[i].LABEL,
            rightData[i].VALUE,
          ]);
        }

        // Create table with four columns
        doc.autoTable({
          startY,
          head: [[{ content: section?.TITLE, colSpan: 4 }]],
          body: tableData,
          theme: "grid",
          headStyles: {
            fillColor: [66, 99, 199],
            textColor: [255, 255, 255],
            fontSize: 10,
            halign: "center",
          },
          styles: { fontSize: 8 },
          columnStyles: {
            0: { cellWidth: 35, fontStyle: "bold" },
            1: { cellWidth: 55 },
            2: { cellWidth: 35, fontStyle: "bold" },
            3: { cellWidth: 55 },
          },
        });

        // Update the startY position based on the table height
        const tableHeight = doc.previousAutoTable.finalY - startY;
        startY += tableHeight + spacing;

        // Add horizontal line
        doc.setLineWidth(0.1); // Set the line width (adjust as needed)
        doc.line(
          lineX,
          startY - spacing / 2,
          lineX + lineWidth,
          startY - spacing / 2
        );
      }
    } else if (section.DISPLAY_TYPE === "OnlyExport") {
      doc.setFont("helvetica", "bold");
      doc.setFontSize(12);
      doc.text(`---------: ${section?.TITLE} :--------`, 10, startY);
      startY += 10;

      doc.setFont("helvetica", "normal");
      doc.setFontSize(10);

      const mappedData = section?.DETAILS?.map((item) => item.VALUE); // Extract the VALUE property
      const formattedData = mappedData.join("\n"); // Join the values with newline separator

      // If this is not the first "onlyExport" section, add spacing between previous and current section
      if (exportContentStartY !== 0) {
        startY += spacing;
      }

      const maxWidth = pageWidth - 10; // Adjust the maximum width as needed
      const lines = doc.splitTextToSize(formattedData, maxWidth);
      doc.text(lines, 10, startY); // Display the content

      startY += lines.length * 5; // Adjust the vertical position based on the number of lines
      exportContentStartY = startY; // Update the starting Y position for the next "onlyExport" content
    }
  }
  startY += 10;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(12);
  // const bankNameX = logoX + logoWidth + 30;
  // const bankNameY = logoY + 7;
  doc.text(
    "********************************************** END OF STATEMENT *******************************************",
    10,
    startY
  );

  doc.save("Statement Of Account.pdf");
};

export default exportToPDF;
