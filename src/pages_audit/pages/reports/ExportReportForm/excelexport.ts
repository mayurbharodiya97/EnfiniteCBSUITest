//@ts-nocheck
export const exportToExcel = ({
  title,
  columns,
  rows,
  columnsSelected,
  data,
  auth,
  retrievalParams,
  filters,
  globalFilter,
  columnLabel,
}) => {
  const theme = {
    bg: "4263C7",
    white: "ffffff",
  };

  //  filter columns based on selected column names
  columns = columns.filter((column: { id: number }) =>
    columnsSelected.includes(column.id)
  );

  // get filter date [from/to]
  const { fromDt, toDt } = getRetrievalParaDate(retrievalParams);

  return XlsxPopulate.fromBlankAsync().then((workbook) => {
    const sheet = workbook.sheet(0);

    let cellIndex = 1;
    let one = 1;
    // Add merged header row if checkbox is checked
    if (data.show_header) {
      // set header cells dynamic
      sheet.row(1).height(30);
      sheet.range(cellIndex, one, cellIndex, columns.length).merged(true); // Merge the first 3 cells of the first row
      const headerCell = sheet.cell("A1");
      headerCell.value(auth?.companyName).style({
        bold: true,
        fontSize: 18,
        horizontalAlignment: "center",
        verticalAlignment: "center",
        fill: theme.bg,
        fontColor: theme.white,
      });

      cellIndex += 1;
    }

    // get all applied filters/params for title
    let fileTitle = getTitleFilters(
      retrievalParams,
      filters,
      globalFilter,
      columnLabel
    );
    // title name row
    sheet
      .range(cellIndex, one, cellIndex, columns.length)
      .merged(true)
      .style({ border: true, wrapText: true }); // Merge cells
    const branch = sheet.cell(`A${cellIndex}`);
    branch
      .value(`Branch: ${auth?.user?.branchCode}- ${auth?.user?.branch}`)
      .style({
        bold: true,
        fontSize: 12,
        horizontalAlignment: "center",
        fontColor: theme.bg,
      });

    sheet
      .range(cellIndex + 1, one, cellIndex + 1, columns.length)
      .merged(true)
      .style({ border: true }); // Merge cells
    const titleNameCell = sheet.cell(`A${cellIndex + 1}`);
    titleNameCell.value(`Working Date: ${auth?.workingDate}  ${title}`).style({
      bold: true,
      fontSize: 12,
      horizontalAlignment: "center",
      fontColor: theme.bg,
    });
    cellIndex += 1;
    // title filters row
    // range(startRowNumber, startColumnNumber, endRowNumber, endColumnNumber)

    sheet
      .range(cellIndex + 1, one, cellIndex + 1, columns.length)
      .merged(true)
      .style({ border: true, wrapText: true }); // Merge cells
    const titleFilterCell = sheet.cell(`A${cellIndex + 1}`);
    titleFilterCell.value(`${fileTitle}`).style({
      bold: true,
      fontSize: 12,
      horizontalAlignment: "center",
      fontColor: theme.bg,
    });
    cellIndex += 2;

    // Add column headers
    const headers = columns.map((d: { cname: any }) => d.cname);
    headers.forEach((header: any, index: number) => {
      sheet
        .cell(cellIndex, index + 1)
        .value(header)
        .style({ bold: true, border: true });
    });

    // get dynamic row w.r.t column selected
    const filteredRows = getDynamicRow(rows, columns);

    filteredRows.forEach((rowData, rowIndex) => {
      Object.values(rowData).forEach((value, columnIndex) => {
        sheet
          .cell(rowIndex + cellIndex + 1, columnIndex + 1)
          .value(value)
          .style({ border: true });
      });
    });

    cellIndex += filteredRows.length + 3;

    // get generated details
    let two = 2;
    sheet
      .cell(cellIndex, one)
      .value("Generated by")
      .style({ bold: true, border: true });
    sheet.cell(cellIndex, two).value(auth?.user?.id).style({ border: true });

    cellIndex += 1;

    sheet
      .cell(cellIndex, one)
      .value("Printed on")
      .style({ bold: true, border: true });
    sheet
      .cell(cellIndex, two)
      .value(dateFns.format(new Date(), "DD/MM/YYYY HH:mm:ss"))
      .style({ border: true });

    // set column width dynamically
    if (data.export_type === "EXCEL") {
      const columnKeys = Object.keys(filteredRows[0]);
      const maxLengths = columnKeys.map((_, colIndex) => {
        let maxLength = 8;

        for (let i = 0; i < filteredRows.length; i++) {
          const row = filteredRows[i];
          const cellValue = (row[columnKeys[colIndex]] || "").toString().trim();
          if (cellValue.length > maxLength) {
            maxLength = cellValue.length;
          }
        }

        return maxLength;
      });

      // Set the column widths
      const widthExtendBy = 4;
      columnKeys.forEach((_, colIndex) => {
        sheet
          .column(colIndex + one)
          .width(maxLengths[colIndex] + widthExtendBy);
      });
    }

    return workbook.outputAsync().then((blob) => {
      return { downloadTitle: `${title} ${fromDt}-${toDt}.xlsx`, blob };
    });
  });
};
